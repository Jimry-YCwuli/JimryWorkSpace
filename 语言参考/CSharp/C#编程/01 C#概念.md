# C#概念

---

## 1.1 C#类型系统

- C# 是一种强类型语言。 每个变量和常量都有一个类型， 每个方法声明都为每个输入参数和返回值指定名称、参数数量以及类型和种类（值、引用或输出）。 .NET 类库定义了一组内置数值类型以及表示各种逻辑构造的更复杂类型（如文件系统、网络连接、对象的集合和数组以及日期）。 典型的 C# 程序使用类库中的类型，以及对程序问题域的专属概念进行建模的用户定义类型。

> 类型中可存储的信息包括以下项：
  >
  >- 类型变量所需的存储空间。
  >- 可以表示的最大值和最小值。
  >- 包含的成员（方法、字段、事件等）。
  >- 继承自的基类型。
  >- 它实现的接口。
  >- 在运行时分配变量内存的位置。
  >- 允许执行的运算种类。

- var 匿名类型，在局部空间内系统自动推断其类型。

- 内置类型：C# 提供了一组标准的内置类型来表示整数、浮点值、布尔表达式、文本字符、十进制值和其他数据类型。 还有内置的 string 和 object 类型。 这些类型可供在任何 C# 程序中使用。

- 自定义类型：可以使用结构、类、接口，和枚举构造创建用户的自定义类型。 .NET 类库本身就是 Microsoft 提供的一组自定义类型，以供在自己的应用程序中使用。对于其他类型，只有在显式添加对定义这些类型的程序集的项目引用时才可用。

---

### 1.1.1 通用类型系统

- 对于 .NET 中的类型系统，请务必了解以下两个基本要点：
  - 它支持继承原则。 类型可以派生自其他类型（称为*基类型*）。 派生类型继承（有一些限制）基类型的方法、属性和其他成员。 基类型可以继而从某种其他类型派生，在这种情况下，派生类型继承其继承层次结构中的两种基类型的成员。 所有类型（包括 System.Int32C# 关键字：int 等内置数值类型）最终都派生自单个基类型，即 System.Object（C# 关键字：object。 这样的统一类型层次结构称为通用类型系统 (CTS)。 若要详细了解 C# 中的继承，请参阅继承。
  - CTS 中的每种类型被定义为值类型或引用类型。 这些类型包括 .NET 类库中的所有自定义类型以及你自己的用户定义类型。 使用 struct 关键字定义的类型是值类型；所有内置数值类型都是 structs。 使用 class 关键字定义的类型是引用类型。 引用类型和值类型遵循不同的编译时规则和运行时行为。

---

### 1.1.2 值类型

- 值类型派生自 System.ValueType（派生自 System.Object）。值类型变量直接包含它们的值，这意味着在声明变量的任何上下文中内联分配内存。 对于值类型变量，没有单独的堆分配或垃圾回收开销。

- 值类型分为两类：结构和枚举。

- 值类型已密封，这意味着不能从任何值类型（例如 System.Int32）派生类型。 不能将结构定义为从任何用户定义的类或结构继承，因为结构只能从 System.ValueType 继承。

- 一个结构可以实现一个或多个接口。 可将结构类型强制转换为它实现的任何接口类型；强制转换会导致装箱操作发生，以将结构包装在托管堆上的引用类型对象内。

- 另一种值类型是枚举。 枚举定义的是一组已命名的整型常量。所有枚举从 System.Enum（继承自 System.ValueType）继承。 适用于结构的所有规则也适用于枚举。

---

### 1.1.3 引用类型

- 定义为 类、委托、数组或 接口的类型是 引用类型。 在运行时，当声明引用类型的变量时，该变量会一直包含值 null，直至使用 new 运算符显式创建对象，或者为该变量分配已经在其他位置使用 new 创建的对象 。

- 创建对象后，内存会在托管堆上进行分配，并且变量只保留对对象位置的引用。 对于托管堆上的类型，在分配内存和 CLR 自动内存管理功能（称为“垃圾回收”）回收内存时都会产生开销。 但是，垃圾回收已是高度优化，并且在大多数情况下，不会产生性能问题。

- 引用类型完全支持继承。 创建类时，可以从其他任何未定义为密封的接口或类继承，而其他类可以从你的类继承并重写虚拟方法。

---

### 1.1.4 文本值类型

- 在 C# 中，文本值从编译器接收类型。 可以通过在数字末尾追加一个字母来指定数字文本应采用的类型。

---

### 1.1.5 泛型类型

- 可使用一个或多个类型参数声明、作为客户端代码在创建类型实例时将提供的实际类型（具体类型）的占位符的类型。 这种类型称为泛型类型。

---

### 1.1.6 编译时类型和运行时类型

- 变量可以具有不同的编译时和运行时类型。 编译时类型是源代码中变量的声明或推断类型。 运行时类型是该变量所引用的实例的类型。

---

## 1.2 可为空引用类型

> C#8.0 引入了“可为空引用类型”和“不可为空引用类型”

- 引用不应为 null。 当变量不应为 null 时，编译器会强制执行规则，以确保在不首先检查它们是否为 null 的情况下，取消引用这些变量是安全的：
  - 必须将变量初始化为非 null 值。
  - 变量永远不能赋值为 null。
- 引用可为 null。 当变量可以为 null 时，编译器会强制执行不同的规则以确保你已正确检查空引用：
  - 只有当编译器可以保证该值不为 null 时，才可以取消引用该变量。
  - 这些变量可以使用默认的 null 值进行初始化，也可以在其他代码中赋值为 null。

---

## 1.3 命名空间

> 在两个方面被大量使用。 首先，.NET 使用命名空间来组织它的许多类。其次，在较大的编程项目中，声明自己的命名空间可以帮助控制类和方法名称的范围。

- 命名空间具有以下属性：
  - 它们组织大型代码项目。
  - 通过使用 . 运算符分隔它们。
  - using 指令可免去为每个类指定命名空间的名称。
  - global 命名空间是“根”命名空间：global::System 始终引用 .NET System 命名空间。

---

## 1.4 类

- 定义为 类的一个类型是 引用类型。 在运行时，如果声明引用类型的变量，此变量就会一直包含值 null，直到使用 new 运算符显式创建类实例，或直到为此变量分配可能已在其他位置创建的兼容类型的对象。

- 类完全支持继承，这是面向对象的编程的基本特点。 创建类时，可以继承自其他任何未定义为 sealed 的类，而且其他类也可以继承自你的类并重写类虚方法。 此外，你可以实现一个或多个接口。

- 继承是通过使用 派生 来完成的，这意味着类是通过使用其数据和行为所派生自的 基类 来声明的。 基类通过在派生的类名称后面追加冒号和基类名称来指定。

- 类可以声明为 abstract（抽象）。 抽象类包含抽象方法，抽象方法包含签名定义但不包含实现。 抽象类不能实例化。 只能通过可实现抽象方法的派生类来使用该类。 与此相反，sealed（密封）类不允许其他类继承。

- 类定义可以在不同的源文件之间分割。

---

## 1.5 析构元组和其他类型

- 元组提供一种从方法调用中检索多个值的轻量级方法。 但是，一旦检索到元组，就必须处理它的各个元素。

- 从 C# 7.0 开始，用户可从元组中检索多个元素，或在单个析构操作中从对象检索多个字段值、属性值和计算值。 析构元组时，将其元素分配给各个变量。 析构对象时，将选定值分配给各个变量。

- C# 提供内置的元组析构支持，可在单个操作中解包一个元组中的所有项。 用于析构元组的常规语法与用于定义元组的语法相似：将要向其分配元素的变量放在赋值语句左侧的括号中。

```csharp
var (name, address, city, zip) = contact.GetAddressInfo();
var（a,b,c,d）=("haha",1,1.5f,new classA());
```

- 析构元组时，通常只需要关注某些元素的值。 从 C# 7.0 开始，便可利用 C# 对弃元的支持，弃元是一种仅能写入的变量，且其值将被忽略。 在赋值中，通过下划线字符 (\_) 指定弃元。 可弃元任意数量的值，且均由单个弃元 _ 表示。

```csharp
 var (_, _, _, pop1, _, pop2) = QueryCityDataForYears("New York City", 1960, 2010);
```

---

## 1.6 接口

- 接口包含非抽象类或结构必须实现的一组相关功能的定义。 接口可以定义 static 方法，此类方法必须具有实现。 从 C# 8.0 开始，接口可为成员定义默认实现。 接口不能声明实例数据，如字段、自动实现的属性或类似属性的事件。

- 接口可以包含实例方法、属性、事件、索引器或这四种成员类型的任意组合。 接口可以包含静态构造函数、字段、常量或运算符。

- 若要实现接口成员，实现类的对应成员必须是公共、非静态，并且具有与接口成员相同的名称和签名。

- 当类或结构实现接口时，类或结构必须为该接口声明的所有成员提供实现，但不提供默认实现。 但是，如果基类实现接口，则从基类派生的任何类都会继承该实现。

---

### 1.6.1 接口摘要

- 接口具有以下属性：
  - 接口通常类似于只有抽象成员的抽象基类。 实现接口的任何类或结构都必须实现其所有成员。 接口可以选择性地定义其部分或全部成员的默认实现。 有关详细信息，请参阅默认接口方法。
  - 接口无法直接进行实例化。 其成员由实现接口的任何类或结构来实现。
  - 一个类或结构可以实现多个接口。 一个类可以继承一个基类，还可实现一个或多个接口。

---

## 1.7 方法

- 方法是包含一系列语句的代码块。 程序通过调用该方法并指定任何所需的方法参数使语句得以执行。 在 C# 中，每个执行的指令均在方法的上下文中执行。 Main 方法是每个 C# 应用程序的入口点，并在启动程序时由公共语言运行时 (CLR) 调用。

---

### 1.7.1 方法签名

- 通过指定在 class 或 struct 中声明方法：
  - 可选的访问级别，如 public 或 private。 默认值为 private。
  - 可选的修饰符，如 abstract 或 sealed。
  - 返回值，或 void（如果该方法不具有）。
  - 方法名称。
  - 任何方法参数。 方法参数在括号内，并且用逗号分隔。 空括号指示方法不需要任何参数。

>出于方法重载的目的，方法的返回类型不是方法签名的一部分。 但是在确定委托和它所指向的方法之间的兼容性时，它是方法签名的一部分。

---

### 1.7.2 方法调用

- 方法可以是实例的或静态的。 调用实例方法需要将对象实例化，并对该对象调用方法；实例方法可对该实例及其数据进行操作。 通过引用该方法所属类型的名称来调用静态方法；静态方法不对实例数据进行操作。 尝试通过对象实例调用静态方法会引发编译器错误。

- 该方法定义指定任何所需参数的名称和类型。 调用方调用该方法时，它为每个参数提供了称为自变量的具体值。 自变量必须与参数类型兼容，但调用代码中使用的自变量名（如果有）不需要与方法中定义的自变量名相同。

- 调用方法时，也可以使用命名的自变量，而不是位置自变量。 使用命名的自变量时，指定参数名，然后后跟冒号（":"）和自变量。 只要包含了所有必需的自变量，方法的自变量可以任何顺序出现。

- 可以同时使用位置自变量和命名的自变量调用方法。 但是，只有当命名参数位于正确位置时，才能在命名自变量后面放置位置参数。

```csharp
var travelTime = moto.Drive(170, speed: 55);//结合使用
var travelTime = moto.Drive(speed: 60, miles: 170);//使用命名自变量
moto.Drive(5, 20);//位置自变量
```

---

### 1.7.3 继承和重写方法

》类型可以使用 override 关键字并提供重写方法的实现来重写继承的成员。 方法签名必须与重写的方法的签名一样。

```csharp
using System;
public class Person
{
   public String FirstName;
   public override bool Equals(object obj)//重写Object类Equals方法
   {
      var p2 = obj as Person;
      if (p2 == null)
         return false;
      else
         return FirstName.Equals(p2.FirstName);
   }
   public override int GetHashCode()//重写Object方法虚方法 
  {
      return FirstName.GetHashCode();
   }
```

---

### 1.7.4 按值传递参数

- 值类型按值传递给方法时，传递的是对象的副本而不是对象本身。 因此，当控件返回调用方时，对已调用方法中的对象的更改对原始对象无影响。

- 引用类型的对象按值传递到方法中时，将按值传递对对象的引用。 也就是说，该方法接收的不是对象本身，而是指示该对象位置的自变量。 控件返回到调用方法时，如果通过使用此引用更改对象的成员，此更改将反映在对象中。 但是，当控件返回到调用方时，替换传递到方法的对象对原始对象无影响。

---

### 1.7.5 按引用传递参数

- 如果想要更改方法中的自变量值并想要在控件返回到调用方法时反映出这一更改，请按引用传递参数。 要按引用传递参数，请使用 ref 或 out 关键字。 还可以使用 in 关键字，按引用传递值以避免复制，但仍防止修改。

- 引用参数所使用的常见模式涉及交换变量值。 将两个变量按引用传递给一个方法，然后该方法将二者内容进行交换。

- 通过传递引用类型的参数，可以更改引用本身的值，而不是其单个元素或字段的值。

---

### 1.7.6 参数数组

- 通过使用 params 关键字来指示一个参数是一个参数数组，可通过可变数量的自变量来调用方法。 使用 params 关键字标记的参数必须为数组类型，并且必须是该方法的参数列表中的最后一个参数。

- 然后，调用方可通过以下四种方式中的任一种来调用方法：
  - 传递相应类型的数组，该类型包含所需数量的元素。
  - 向该方法传递相应类型的单独自变量的逗号分隔列表。
  - 传递 null。
  - 不向参数数组提供参数。

---

### 1.7.7 可选参数和自变量

- 方法定义可指定其参数是必需的还是可选的。 默认情况下，参数是必需的。 通过在方法定义中包含参数的默认值来指定可选参数。 调用该方法时，如果未向可选参数提供自变量，则改为使用默认值。

- 参数的默认值必须由以下几种表达式中的一种来赋予：
  - 常量，例如文本字符串或数字。
  - new ValType() 形式的表达式，其中 ValType 是值类型。 请注意，这会调用该值类型的隐式无参数构造函数，该函数不是类型的实际成员。
  - default(ValType) 形式的表达式，其中 ValType 是值类型。

- 如果某个方法同时包含必需的和可选的参数，则在参数列表末尾定义可选参数，即在定义完所有必需参数之后定义。

```csharp
using System;
public class Options
{
   public void ExampleMethod(int required, int optionalInt = default(int),
                             string description = "Optional Description")
   {
      Console.WriteLine("{0}: {1} + {2} = {3}", description, required,
                        optionalInt, required + optionalInt);
   }
}
```

- 使用可选参数会影响重载决策，或影响 C# 编译器决定方法应调用哪个特定重载时所使用的方式，如下所示：
  - 如果方法、索引器或构造函数的每个参数是可选的，或按名称或位置对应于调用语句中的单个自变量，且该自变量可转换为参数的类型，则方法、索引器或构造函数为执行的候选项。
  - 如果找到多个候选项，则会将用于首选转换的重载决策规则应用于显式指定的自变量。 将忽略可选形参已省略的实参。
  - 如果两个候选项不相上下，则会将没有可选形参的候选项作为首选项，对于这些可选形参，已在调用中为其省略了实参。 这是重载决策中的常规引用的结果，该引用用于参数较少的候选项。

---

### 1.7.8 返回值

- 方法可以将值返回到调用方。 如果列在方法名之前的返回类型不是 void，则该方法可通过使用 return 关键字返回值。

- 带 return 关键字且后跟与返回类型匹配的变量、常数或表达式的语句将向方法调用方返回该值。 具有非空的返回类型的方法都需要使用 return 关键字来返回值。

- return 关键字还会停止执行该方法。

- 如果返回类型为 void，没有值的 return 语句仍可用于停止执行该方法。 没有 return 关键字，当方法到达代码块结尾时，将停止执行。

---

### 1.7.9 扩展方法

- 通常，可以通过两种方式向现有类型添加方法：
  - 修改该类型的源代码。 当然，如果并不拥有该类型的源代码，则无法执行该操作。 并且，如果还添加任何专用数据字段来支持该方法，这会成为一项重大更改。
  - 在派生类中定义新方法。 无法使用其他类型（如结构和枚举）的继承来通过此方式添加方法。 也不能使用此方式向封闭类“添加”方法。

- 使用扩展方法，可向现有类型“添加”方法，而无需修改类型本身或在继承的类型中实现新方法。 扩展方法也无需驻留在与其扩展的类型相同的程序集中。 要把扩展方法当作是定义的类型成员一样调用。

---

### 1.7.10 Expression-Bodied 成员

- 具有立即仅返回表达式结果，或单个语句作为方法主题的方法定义很常见。

```csharp
public Point Move(int dx, int dy) => new Point(x + dx, y + dy);
public void Print() => Console.WriteLine(First + " " + Last);
// Works with operators, properties, and indexers too.
public static Complex operator +(Complex a, Complex b) => a.Add(b);
public string Name => First + " " + Last;
public Customer this[long id] => store.LookupCustomer(id);
```

- 如果该方法返回 void 或是异步方法，则该方法的主体必须是语句表达式（与 lambda 相同）。 对于属性和索引器，两者必须是只读，并且不使用 get 访问器关键字。

---

## 1.7.11 迭代器

- 迭代器对集合执行自定义迭代，如列表或数组。 迭代器使用 yield return 语句返回元素，每次返回一个。 到达 yield return 语句后，会记住当前位置，以便调用方可以请求序列中的下一个元素。

- 迭代器的返回类型可以是 IEnumerable、 IEnumerable\<T>、 IEnumerator或 IEnumerator\<T>。

---

## 1.8 属性

- 属性是 C# 中的一等公民。 借助该语言所定义的语法，开发人员能够编写出准确表达其设计意图的代码。

- 访问属性时，其行为类似于字段。 但与字段不同的是，属性通过访问器实现；访问器用于定义访问属性或为属性赋值时执行的语句。

---

### 1.8.1 属性的自动实现

- 属性语法是字段的自然延伸。 字段定义存储位置：

```csharp
public class Person
{
    public string FirstName;
    // remaining implementation removed from listing
}
public class Person
{
    public string FirstName { get; set; }
    // remaining implementation removed from listing
}
```

- 有时，需要将属性初始化为其类型默认值以外的值。 C# 通过在属性的右括号后设置值达到此目的。 对于 FirstName 属性的的初始值，你可能更希望设置为空字符串而非 null。 可按如下所示进行指定：
  
```csharp
public class Person
{
    public string FirstName { get; set; } = string.Empty;
    // remaining implementation removed from listing
}  
```

>- 方案：通过get和set访问器中编写所需代码，可以创建不同的方案。
>- 验证：可以在 set 访问器中编写代码，确保由某个属性表示的值始终有效。 可通过将 throw 表达式用作属性资源库验证的一部分 。
>- 属性可以只有只读或者只写访问器，属性是类或对象中一种只能字段形式，从外部看像是普通字段，但是属性可以通过丰富的C#功能来实现，通过提供验证，不同的可访问性，迟缓计算或方案所需的任何要求。

---

## 1.9 索引器

- 索引器类似于属性。 很多时候，创建索引器与创建属性所使用的编程语言特性是一样的。 索引器使属性可以被索引：使用一个或多个参数引用的属性。 这些参数为某些值集合提供索引。

- 语法：

```csharp
//可以通过变量名和方括号访问索引器。 将索引器参数放在方括号内：
var item = someObject["key"];
someObject["AnotherKey"] = item;
//使用 this 关键字作为属性名声明索引器，并在方括号内声明参数。
public int this[string key]
{
    get { return storage.Find(key); }
    set { storage.SetAt(key, value); }
}
```

> 索引器可以使用任何有效的访问修饰符（public、protected internal、protected、internal、private 或 private protected）。 它们可能是密封、虚拟或抽象的。 与属性一样，可以在索引器中为 get 和 set 访问器指定不同的访问修饰符。 你还可以指定只读索引器（忽略 set 访问器）或只写索引器（忽略 get 访问器）。
>
>属性的各种用法同样适用于索引器。 此规则的唯一例外是“自动实现属性”。 编译器无法始终为索引器生成正确的存储。

---

## 1.10 弃元

- 从 C# 7.0 开始，C# 支持弃元，这是一种在应用程序代码中人为取消使用的占位符变量。 弃元相当于未赋值的变量；它们没有值。 弃元将意图传达给编译器和其他读取代码的文件：你打算忽略表达式的结果。 你可能需要忽略表达式的结果、元组表达式的一个或多个成员、方法的 out 参数或模式匹配表达式的目标。
- 因为只有一个弃元变量，甚至不为该变量分配存储空间。 所以，弃元可以减少内存分配。 弃元使代码意图更加明确。 它们可以增强其可读性和可维护性。
- 通过将下划线 (_) 赋给一个变量作为其变量名，指示该变量为一个占位符变量。

```csharp
(_, _, area) = city.GetCityInformation(cityName);
```

>- 弃元可用于元组和对象析构。
>- 在switch表达式中用弃元表示未匹配参数的最终通道，但弃元本身不可作为有效的占位符。
>- 在case块中表示非其他case的模式选择。
>- 弃元说明你的意图：不需要或不使用赋值结果。
>- 作为独立弃元用来忽略任何变量。使用独立占位符来忽略异步操作返回的 Task 对象。 分配任务的效果等同于抑制操作即将完成时所引发的异常。 这使你的意图更加明确：你需要对 Task 使用弃元，并忽略该异步操作生成的任何错误。

---

## 1.11 泛型

- 泛型将类型参数的概念引入 .NET，这样就可设计具有以下特征的类和方法：在客户端代码声明并初始化这些类或方法之前，这些类或方法会延迟指定一个或多个类型。 例如，通过使用泛型类型参数 T，可以编写其他客户端代码能够使用的单个类，而不会产生运行时转换或装箱操作的成本或风险。

- 泛型类和泛型方法兼具可重用性、类型安全性和效率，这是非泛型类和非泛型方法无法实现的。 泛型通常与集合以及作用于集合的方法一起使用。 System.Collections.Generic 命名空间包含几个基于泛型的集合类。 非泛型集合（如 ArrayList）不建议使用，并且保留用于兼容性目的。

- 泛型概述:
  - 使用泛型类型可以最大限度地重用代码、保护类型安全性以及提高性能。
  - 泛型最常见的用途是创建集合类。
  - .NET 类库在 System.Collections.Generic 命名空间中包含几个新的泛型集合类。 应尽可能使用这些类来代替某些类，如 System.Collections 命名空间中的 ArrayList。
  - 可以创建自己的泛型接口、泛型类、泛型方法、泛型事件和泛型委托。
  - 可以对泛型类进行约束以访问特定数据类型的方法。
  - 在泛型数据类型中所用类型的信息可在运行时通过使用反射来获取。

---

## 1.12 迭代器

- 编写的几乎每个程序都需要循环访问集合。 因此需要编写代码来检查集合中的每一项。

- 还需创建迭代器方法，这些方法可为该类的元素生成迭代器（该对象遍历容器，尤其是列表）。 这些方法可用于：
  - 对集合中的每个项执行操作。
  - 枚举自定义集合。
  - 扩展 LINQ 或其他库。
  - 创建数据管道，以便数据通过迭代器方法在管道中有效流动。

---

### 1.12.1 使用foreach执行循环访问

- 枚举集合非常简单：使用 foreach 关键字枚举集合，从而为集合中的每个元素执行一次嵌入语句：

```csharp
foreach (var item in collection)
{
   Console.WriteLine(item.ToString());
}
```

>foreach 语句并非完美无缺。 它依赖于 .NET Core 库中定义的 2 个泛型接口，才能生成循环访问集合所需的代码：IEnumerable\<T> 和 IEnumerator\<T>。

---

### 1.12.2 使用迭代器方法的枚举源

- 迭代器方法用于定义请求时如何在序列中生成对象。 使用`yield return`上下文关键字定义迭代器方法。

```csharp
public IEnumerable<int> GetSingleDigitNumbers()
{
    yield return 0;
    yield return 1;
    yield return 2;
    yield return 3;
    yield return 4;
    yield return 5;
    yield return 6;
    yield return 7;
    yield return 8;
    yield return 9;
}
//简化
public IEnumerable<int> GetSingleDigitNumbers()
{
    int index = 0;
    while (index < 10)
        yield return index++;
}
```

- 数据流实例

```csharp
//假设你正在处理一个 IoT 项目，设备传感器生成了大量数据流。 为了获知数据，需要编写一个对每第 N 个数据元素进行采样的方法。 通过以下小迭代器方法可实现此目的：
public static IEnumerable<T> Sample(this IEnumerable<T> sourceSequence, int interval)
{
    int index = 0;
    foreach (T item in sourceSequence)
    {
        if (index++ % interval == 0)
            yield return item;
    }
}
```

>迭代器方法有一个重要限制：在同一方法中不能同时使用 return 语句和 yield return 语句。

---

### 1.12.3 深入了解foreach语句

- foreach 语句可扩展为使用 IEnumerable\<T> 和 IEnumerator\<T> 接口的标准用语，以便循环访问集合中的所有元素。 还可最大限度减少开发人员因未正确管理资源所造成的错误。

```csharp
//原始结构
foreach (var item in collection)
{
   Console.WriteLine(item.ToString());
}
//编译器转化类似于
IEnumerator<int> enumerator = collection.GetEnumerator();
while (enumerator.MoveNext())
{
    var item = enumerator.Current;
    Console.WriteLine(item.ToString());
}
//编译器完整编译
{
    var enumerator = collection.GetEnumerator();
    try
    {
        while (enumerator.MoveNext())
        {
            var item = enumerator.Current;
            Console.WriteLine(item.ToString());
        }
    } finally
    {
        // dispose of enumerator.
    }
}
//枚举器的释放方式finally取决于 enumerator 类型的特征。 一般情况下，finally 子句扩展为：
finally
{
   (enumerator as IDisposable)?.Dispose();
}
//如果 enumerator 的类型为已密封类型，并且不存在从类型 enumerator 到 IDisposable 的隐式转换，则 finally 子句扩展为一个空白块：
finally
{
}
//如果存在从类型 enumerator 到 IDisposable 的隐式转换，并且 enumerator 是不可为 null 的值类型，则 finally 子句扩展为：
finally
{
   ((IDisposable)enumerator).Dispose();
}
```

---

## 1.13 委托

- 在 .NET 中委托提供 后期绑定 机制。 后期绑定意味着调用方在你所创建的算法中至少提供一个方法来实现算法的一部分。

- 委托的语言设计目标：
  - 团队想要拥有可用于任何后期绑定算法的公共语言构造。
  - 其次，该团队希望支持单一和多播方法调用。
  - 最后，团队认识到事件模式是一个特定模式，委托或任何后期绑定算法在这种模式下都非常有用。
  - 所有这些工作的结果是 C# 和 .NET 中的委托和事件支持。

### 1.13.1 定义委托

- 使用类似于定义方法签名的语法来定义委托类型。 只需向定义添加 delegate 关键字即可。

```csharp
// From the .NET Core library
// Define the delegate type:
public delegate int Comparison<in T>(T left, T right);
```

- 编译器还会为此新类型生成添加和移除处理程序，以便此类的客户端可以对实例的调用列表添加和移除方法。 编译器会强制所添加或移除的方法的签名与声明该方法时使用的签名匹配。

---

### 1.13.2 强委托类型

```csharp
public delegate void Action();
public delegate void Action<in T>(T arg);
public delegate void Action<in T1, in T2>(T1 arg1, T2 arg2);
// Other variations removed for brevity.
```

>Action 委托的变体可包含多达 16 个参数，如 Action<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16>。 重要的是这些定义对每个委托参数使用不同的泛型参数：这样可以具有最大的灵活性。 方法参数不需要但可能是相同的类型。

```csharp
public delegate TResult Func<out TResult>();
public delegate TResult Func<in T1, out TResult>(T1 arg);
public delegate TResult Func<in T1, in T2, out TResult>(T1 arg1, T2 arg2);
// Other variations removed for brevity
```

>Func 委托的变体可包含多达 16 个输入参数，如 Func<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,TResult>。 按照约定，结果的类型始终是所有 Func 声明中的最后一个类型参数。

---

## 1.14 事件

- 和委托类似，事件是后期绑定机制。 实际上，事件是建立在对委托的语言支持之上的。

- 事件是对象用于（向系统中的所有相关组件）广播已发生事情的一种方式。 任何其他组件都可以订阅事件，并在事件引发时得到通知。

- 可以定义应针对类引发的事件。 使用事件时，需要注意的一点是特定事件可能没有任何注册的对象。 必须编写代码，以确保在未配置侦听器时不会引发事件。

- 通过订阅事件，还可在两个对象（事件源和事件接收器）之间创建耦合。 需要确保当不再对事件感兴趣时，事件接收器将从事件源取消订阅。

---

## 1.14.1 事件支持的设计目标

- 事件的语言设计针对这些目标：
  - 在事件源和事件接收器之间启用非常小的耦合。 这两个组件可能不会由同一个组织编写，甚至可能会通过完全不同的计划进行更新。
  - 订阅事件并从同一事件取消订阅应该非常简单。
  - 事件源应支持多个事件订阅服务器。 它还应支持不附加任何事件订阅服务器。

- 事件的目标与委托的目标非常相似。 因此，事件语言支持基于委托语言支持构建。

---

### 1.14.2 事件的语言支持

- 用于定义事件以及订阅或取消订阅事件的语法是对委托语法的扩展。

- 定义使用 event 关键字的事件：

```csharp
public event EventHandler<FileListArgs> Progress;
```

- 想要引发事件时，使用委托调用语法调用事件处理程序：

```csharp
Progress?.Invoke(this, new FileListArgs(file));
//如委托部分中所介绍的那样，?. 运算符可以轻松确保在事件没有订阅服务器时不引发事件。
```

- 通过使用 += 运算符订阅事件：

```csharp
EventHandler<FileListArgs> onProgress = (sender, eventArgs) =>
    Console.WriteLine(eventArgs.FoundFile);
fileLister.Progress += onProgress;
```

- 使用 -= 运算符取消订阅：
  
```csharp
fileLister.Progress -= onProgress;
```

>请务必为表示事件处理程序的表达式声明局部变量。 这将确保取消订阅删除该处理程序。 如果使用的是 lambda 表达式的主体，则将尝试删除从未附加过的处理程序，此操作为无效操作。

---
