# 第06部分 类型修饰符

---

## 6.1 abstract

---

- 指示被修改内容的实现已丢失或不完整。表现为抽象。
- 抽象类是不可自身实例化的，抽象可以修饰类，方法，属性，索引器和事件。

### 6.1.1 抽象类功能

1. 抽象类不能自身实例化，可接口的实现方式相似，使用里氏替换原则。其中可能包含方法和访问器，无法使用sealed修饰符来修改抽象类，派生自抽象类的非抽象类必须提供其父类所有抽象成员的实现。
2. 抽象方法是隐式的虚拟方法，只有在抽象类中才可以使用，没有实际的方法体。
3. 抽象方法的声明中不能使用static和virtual，且静态属性上不能使用abstract。
4. 抽象子类可以用override abstract复写父类抽象，也可以override重写方法。
5. 抽象类继承接口需要为接口提供实现的方法。

---

## 6.2 async

- 使用async修饰符将方法，lambda表达式，匿名方法指定为异步，参考异步编程

---

## 6.3 const

- 声明某个常量字段或常量局部变量。
- 不能修改，可以为数字，bool，字符串或null引用。
- 初始值设定项必须是可以隐式转换成目标类型的常量表达式。
- 一旦声明类型不能修改。

---

## 6.4 event

- event用于声明发布服务器类中的事件。
- 事件是一种特殊的多播委托，仅可以从声明事件的类或结构中对其进行调用，其他类或结构订阅该事件，则在发布服务器类引发该事件时，将调用其事件处理程序方法。

> 关键字与事件:
>
>- static：使事件可供调用方在任何时候进行调用，即使没有类的实例的时候。
>- virtual：允许在派生类重写该事件行为。
>- sealed：指定对于派生类，不再是虚拟的。
>- abstract：编译器不会生成add与remove事件访问器块，且必须在继承类中进行实现。

---

## 6.5 extern

- extern用于声明在外部实现的方法，常用于使用Interop服务调用非托管代码时与DLLImport特征一起使用，方法必须静态。

---

## 6.6 new

- 此处new为成员修饰符，用于显式隐藏从基类继承的成员，若要访问基类的被隐藏成员，需要用基类实例对象访问，new可用于创建类型的实例或用做泛型类型约束。
- 对同一成员使用override和new时错误的做法，两者互斥。

---

## 6.7 泛型修饰符：in和out

---

- in指定T是逆变的，可以在泛型接口和委托类型中使用in，out指定类型参数T是协变的。

> 逆变：使原类型可以比泛型参数指定的类型派生程度更小，这样可以隐式转换实现逆变接口的类以及隐式转换委托类型。
>
> 协变：使原类型可以比泛型参数指定的类型派生程度更大，这样可以隐式转换实现协变接口的类以及隐式转换委托类型。
>
>引用类型支持泛型参数中的协变和逆变。值类型不支持协变和逆变。
>
>在泛型委托中，in仅在类型定义方法参数的类型，而不是方法的返回类型；out仅在作为方法的返回类型时定义该类型。

---

## 6.8 override

- 用于扩展或修改继承的方法，属性，索引器，事件的抽象或虚拟实现。
- 要求的重写方法和属性必须是virtual，abstract，override，不能是非需方法或静态方法。
- 重写virtual不可更改虚方法的访问性。
- 不能用new，static或virtual修改重写方法。
- 重写属性声明必须指定完全相同的访问修饰，类型和名称。

---

## 6.9 readonly

---

- 修饰的字段指示这个变量只在声明期间或者构造函数中进行初始化。

### 6.9.1 特征

- 属于readonly值类型字段不可变，引用字段必须始终引用同一对象，但对象是可变的，因此readoniy可防止字段替换引用类型的其他实例，但不会阻止只读字段修改字段的实例数据。不要声明只读可变引用类型。
- 在readonly struct类型定义中，struct不可变，在其类型内的成员声明中，不可修改结构的状态。
- 在ref readonly方法的返回值，表示方法的返回时一个引用，且不允许向该引用写入内容。

### 6.9.2 readonly声明字段赋值条件

- 在声明中初始化变量时。
- 静态字段在静态构造中，实例字段在实例构造函数中。
- 只有在构造函数的上下文中，将readonly字段作为out或ref参数传递才有效。
- ref readonly：ref return上的readonly字段修饰符指示返回的引用无法被修改，ref能返回的类型都能由ref readonly返回。

---

## 6.10 sealed

- sealed表示阻止类被其他类继承。表示此类已被封装。
- 但sealed修饰重写类型时表示该类型在下一次继承时不在具有被重写的特质。sealed必须和override结合使用。
- 在结构体中，其成员都是隐式密封的，所以无法继承结构体。

---

## 6.11 static

- static可声明属于类型本身而不是属于特定对象的静态成员。可以声明静态类；在类接口和结构中，可以将static添加到字段，方法，属性和运算符，事件和构造函数。不能用于索引器和终结器。
- 静态类中只包含静态成员，静态成员在其类中只有一个副本。成员只能由类调用。
- 静态字段的声明初始化规则：

```csharp
static int x=y;
static int y=5;
y=15;//x=0,静态x需要显式赋值才会存在定义。
当x不是静态字段时，x=5，且y变化不会改变x的值。
```

---

## 6.12 unsafe

- unsafe表示上下文不安全，可以在此作用域中使用指针。
- 在类型或成员的声明中使用unsafe，表示其主体以及内部在整个上下文中都是不安全上下文，在不安全作用域可以使用指针，包括方法的参数列表。

---

## 6.13 virtual

- 用于修饰方法，属性，索引器，或事件声明，并使他们可以在派生类中被重写，此方法可被任何被继承的类替代补充，扩展，重写。
- 调用虚方法时，将为替代成员检查该对象的运行时类型，将调用大部分派生类中的该替代成员，如果没有派生类替代该成员，则他可能是原始成员。
- virtual不能与static，abstract，private，或override结合使用。

---

## 6.14 volatile

---

- volatile指示一个字段可以由多个同时执行的线程修改。
- 出于性能原因，编译器运行时系统甚至硬件都可能重新排列对存储器的位置的读取和写入。
- 写入volatile的字段不进行这些优化，确保所有线程观察易失性，写入操作(由任何其他线程执行)时观察顺寻写入操作的执行顺序一致。

### 6.14.1 应用面

- 引用类型，指针类型(不能声明指向可变对象的指针)，简单类型，简单枚举类型(由byte，sbyte，short，ushort，int或uint组成其关联常数项)，已知为引用类型的泛型类型参数，IntPtr和UIntPtr。
- double，long等其他类型无法标记为volatile。
- volatile只能用于class，结构的字段，局部变量不可以。
- 鉴于多线程编程的性质，读取陈旧数据的次数是不可预测的，不同的程序会产生一些不同的结果。volatile修饰的片段将始终获得相同的结果。

---
